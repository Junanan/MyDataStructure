package 二分法查找;
/*
mid 如果被分给右区间，需要向上取整(mid = left + (right - left + 1) / 2;)，保证left能够被新值更新；
或者说 出现 left = mid 的情况就是向上取整 避免了死循环
mid如果被分给左区间，需要向下取整，保证right能够被新值更新。

写法 1： while(left <= right) 这种写法可以认为我们在循环体内部直接查找元素，把当前搜索区间分为三个部分。
如果中间位置的元素的值等于目标元素就直接返回。如果中间位置的元素不是目标元素，
可以根据中间位置元素的值决定在中间位置的左边还是右边继续查找。这种查找方式把待搜索区间分为三个部分：左、中、右。
重要经验：如果我们要找的元素性质非常明确、并且简单，通常这样写就可以。例如「力扣」第 704 题（二分查找），第 633 题（平方数之和）。
写法 2：while(left < right) 这种写法表示在循环体内部排除元素，把当前搜索区间分为两个部分。

这种思路可以很形象地理解为「两边夹」，在解决复杂问题的时候，会使得思考的过程变得简单。

虽然看起来比较多，但是归结起来就 2 种情况：mid 在左边区间和 mid 在右边区间。即：根据 mid 的值，可以判断 nums[mid] 是「一定不是目标元素」还是「有可能是目标元素」，进而判断 mid 的左右两边的区间的性质。

L35 L153 L33

旋转数组一类题 都是判断与边界来缩小区间

 */