package 递归;
//递归需要遵守的重要规则
//
//执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
//方法的局部变量是独立的，不会相互影响, 比如n变量
//如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
//递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
//当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。


//递归题的三部曲
//①找整个递归的终止条件：递归应该在什么时候结束？
//②找返回值：应该给上一级返回什么信息？
//③本级递归应该做什么：在这一级递归中，应该完成什么任务？

//千万不要去纠结每一级递归的调用和返回细节，因为递归是重复做一件事情

//TreeNode root = new TreeNode(4);
//TreeNode n2 = new TreeNode(2);
//TreeNode n7 = new TreeNode(7);
//TreeNode n1 = new TreeNode(1);
//TreeNode n3 = new TreeNode(3);
//TreeNode n6 = new TreeNode(6);
//TreeNode n9 = new TreeNode(9);
//root.left =n2;
//root.right = n7;
//n2.left =n1;
//n2.right =n3;
//n7.left = n6;
//n7.right = n9;
//递归 —— 时间复杂度
//在本文中，我们将重点介绍如何计算递归算法的时间复杂度。
//
//给出一个递归算法，其时间复杂度 {\mathcal{O}(T)}O(T) 通常是递归调用的数量（记作 {R}R） 和计算的时间复杂度的乘积（表示为 {\mathcal{O}(s)}O(s)）的乘积：
//
//{\mathcal{O}(T) = R * \mathcal{O}(s)}O(T)=R∗O(s)
//
//我们来看看下面的一些例子。
//
// 
//
//示例
//也许你还记得，在反转字符串问题中，我们需要以相反的顺序打印字符串，解决问题的递归关系可以表示如下：
//
//printReverse(str) = printReverse(str[1...n]) + print(str[0])
//
//其中 str[1...n] 是输入字符串 str 的子串，仅不含前导字符 str[0]。
//
//如您所见，该函数将被递归调用 n 次，其中 n 是输入字符串的大小。在每次递归结束时，我们只是打印前导字符，因此该特定操作的时间复杂度是恒定的，即 {\mathcal{O}(1)}O(1)。
//
//总而言之，我们的递归函数 printReverse(str) 的总体时间复杂度为 {\mathcal{O}(printReverse) = n * \mathcal{O}(1) = \mathcal{O}(n)}O(printReverse)=n∗O(1)=O(n)。
//
// 
//
//执行树
//对于递归函数，递归调用的数量很少与输入的大小呈线性关系。如果你还记得我们在前一章中讨论过的斐波那契数问题，其递推关系被定义为 f(n) = f(n-1) + f(n-2)。乍一看，在执行斐波那契函数期间计算递归调用的数量似乎并不简单。
//
//在这种情况下，最好采用执行树，这是一个用于表示递归函数的执行流程的树。树中的每个节点都表示递归函数的调用。因此，树中的节点总数对应于执行期间的递归调用的数量。
//
//递归函数的执行树将形成 n 叉树，其中 n 作为递推关系中出现递归的次数。例如，斐波那契函数的执行将形成二叉树，下面的图示展现了用于计算斐波纳契数 f(4) 的执行树。
//
// 
//
//
//
//在 n 层的完全二叉树中，节点的总数为 {2^n -1}2 
//n
// −1。因此 f(n) 中递归数目的上限（尽管不严格）也是 {2^n -1}2 
//n
// −1。那么我们可以估计 f(n) 的时间复杂度为 {\mathcal{O}(2^n)}O(2 
//n
// )。
//记忆化（Memoization）
//在前一章中，我们讨论了通常用于优化递归算法的时间复杂度的记忆化技术。过高速缓存和重用中间结果，记忆化技术可以大大减少递归调用的数量，即减少执行树中的分支数量。在使用记忆化分析递归算法的时间复杂度时，也应该考虑到这种减少。
//
//让我们回到斐波纳契数的例子。通过记忆化技术，我们保存每个索引 n 对应的的斐波那契数的结果。我们确信每个斐波那契数的计算只会发生一次。而从递推关系来看，斐波纳契数 f(n) 将取决于其所有 n-1 个先验斐波纳契数。结果，计算 f(n) 的递归将被调用 n-1 次以计算它所依赖的所有先验数字。
//
//现在，我们可以简单地应用我们在本章开头介绍的公式来计算时间复杂度，即 {\mathcal{O}(1) * n = \mathcal{O}(n)}O(1)∗n=O(n)。记忆化技术不仅可以优化算法的时间复杂度，还可以简化时间复杂度的计算。
//
//在下一篇文章中，我们将讨论如何估计递归算法的空间复杂度。